1.工厂模式
factory-> A B C, product -> A B C   
new构造的哪个product则生产哪个product factory-> create product()

2.抽象工厂模式
factory-> A B C, product -> A B C， car -> A B C  
new构造的哪个product则生产哪个product, 一个工厂可以生产多类产品（product,car） factory-> create product()  car()
抽象工厂模式较好的实现了“开放-封闭”原则

3.单例模式
4.Builder模式
Builder模式强调的是一步步创建对象，并通过相同的创建过程可以获得不同的结果对象

5.Prototype模式
 Prototype 模式提供了自我复制的功能，即新对象的创建可以通过已有对象进行创建(Clone)
 C++中通过拷贝构造函数实现，分为浅层拷贝和深层拷贝（指针、复合对象）

6.Bridge模式
Bridge模式 将抽象部分与它的实现部分分离，使得它们可以独立地变化
优先采用聚合而不是继承
Builder封装了不同的生成组成部分的方式，Bridge封装了不同的实现方式

7.Adapter模式
类模式 Adapter 中，通过 private 继承Adaptee 获得实现继承的效果，而通过 public 继承 Target 获得接口继承的效果

8.Decorator模式
Decorator模式除了采用组合的方式取得了比采用继承方式更好的效果
当需要添加一个操作的时候又不想高层的父类就承载了太多的特征就可以通过Decorator模式来解决

9.Composite模式
Composite 模式通过和 Decorator 模式有着类似的结构图
但是 Composite 模式旨在构造类，而 Decorator 模式重在不生成子类即可给对象添加职责

10.Flyweight模式
Flyweight 模式在实现过程中主要是要为共享对象提供一个存放的“仓库”（对象池）

11.Facade模式
客户程序不需要直接访问子系统对象。Facade模式有助于建立层次结构系统，使对象之间的依赖关系分层，
也可以消除复杂的循环依赖关系降低客户-子系统之间的耦合度

12.Proxy模式
Proxy代理模式为其他对象提供一种代理以控制对这个对象的访问，其最大的好处就是实现了逻辑和实现的彻底解耦

13.Template模式
    Template 模式关键是将通用算法（逻辑）封装起来，而将算法细节让子类实现（多态）。需要注意的是将原语操作（细节算法）定义成
保护（Protected）成员，只供模板方法调用（子类可以）
    Template 模式获得一种反向控制结构效果，这也是面向对象系统的分析和设计中一个原则 DIP
(依赖倒置:Dependency Inversion Principles)。其含义就是父类调用子类的操作（高层模块调用低层模块的操作），
低层模块实现高层模块声明的接口。这样控制权在父类（高层模块），低层模块反而要依赖高层模块
    Template 模式继承的强制性约束关系也让Template有不足的地方，可以看到对于ConcreteClass类中的实现的原语方法PrimitiveOperation，
是不能被别的类复用。假设我们要创建一个AbstractClass的变体AnotherAbstractClass并且两者只是通用算法不一样，其原语操作想复用
AbstractClass的子类的实现。但是这是不可能实现的，因为ConcreteClass继承自AbstractClass，也就继承了 AbstractClass 的通用算法，
AnotherAbstractClass是复用不了ConcreteClass 的实现，因为后者不是继承自前者

14.Strategy模式
(1) Strategy 模式的代码很直观，关键是将算法的逻辑封装到一个类中。
    Strategy策略模式和Template模式要解决的问题是类似的，都是为了给业务逻辑（算法）具体实现和抽象接口之间的解耦
(2) Strategy 模式和 Template 模式实际是实现一个抽象接口的两种方式：继承和组合之间的区别。
    继承的优点是：易于修改和扩展那些被复用的实现；
    缺点是：
        一、破坏了封装性，继承中父类的实现细节暴露给子类了（“白盒”复用）；
        二、当父类的实现更改时，其所有子类将不得不随之改变；
        三、从父类继承而来的实现在运行期间不能改变（编译期间就已经确定了）。
    组合的优点是：
        一、“黑盒”复用，因为被包含对象的内部细节对外是不可见的；
        二、封装性好；
        三、实现和抽象的依赖性很小（组合对象和被组合对象之间的依赖性小）；
        四、可以在运行期间动态定义实现（通过一个指向相同类型的指针，典型的是抽象基类的指针）；
    缺点是：系统中对象过多。
(3) 继承是一种强制性很强的方式，因此也使得基类和具体子类之间的耦合性很强。而组合（委托）的方式则有很小的耦合性，
实现（具体实现）和接口（抽象接口）之间的依赖性很小。组合相比继承可以取得更好的效果，因此在面向对象的设计中的有一条很重要的原则就是：
优先使用（对象）组合，而非类继承(Favor Composition Over Inheritance)

模板模式是将通用算法封装起来，而算法的细节由子类来实现，对外只提供模板方法调用
策略模式是将多种行为算法一一封装起来，通过不同行为策略配置来实现行为类方法
15.State模式
(1) State模式和Strategy模式又很大程度上的相似：它们都有一个 Context 类，都是通过委托（组合）给一个具有多个派生类的多态基类实现
Context的算法逻辑。两者最大的差别就是State模式中派生类持有指向 Context 对象的引用，并通过这个引用调用Context中的方法，但在 
Strategy 模式中就没有这种情况。因此可以说一个 State 实例同样是 Strategy 模式的一个实例，反之却不成立。实际上 State 模式和 
Strategy 模式的区别还在于它们所关注的点不尽相同：State 模式主要是要适应对象对于状态改变时的不同处理策略的实现，而 Strategy则主要是
具体算法和实现接口的解耦（coupling），Strategy 模式中并没有状态的概念（虽然很多时候有可以被看作是状态的概念），并且更加不关心状态的改变了。
(2) State 模式很好地实现了对象的状态逻辑和动作实现的分离，状态逻辑分布在 State 的派生类中实现，而动作实现则可以放在 Context 类中
实现（这也是为什么State派生类需要拥有一个指向 Context 的指针）。这使得两者的变化相互独立，改变 State 的状态逻辑可以很容易复用 
Context 的动作，也可以在不影响 State 派生类的前提下创建 Context 的子类来更改或替换动作实现。
(3) State 模式问题主要是逻辑分散化，状态逻辑分布到了很多的 State 的子类中，很难看到整个的状态逻辑图，这也带来了代码的维护问题

16.Observer
Observer模式应该可以说是应用最多、影响最广的模式之一,建立一个一（Subject）对多（Observer）的依赖关系，并且做到当“一”变化的时候，
依赖这个“一”的多也能够同步改变. Observer 模式也称为发布-订阅（publish-subscribe），目标就是通知的发布者，观察者则是通知的订阅者（接受通知）

17.Memento
Memento备忘录模式将该对象恢复到原先保存的状态

18.Mediator
Mediator 模式是一种很有用并且很常用的模式，它通过将对象间的通信封装到一个类中，将多对多的通信转化为一对多的通信，降低了系统的复杂性

19.command
Command模式实现调用操作的对象和操作的具体实现者之间的解耦
在Command要增加新的处理对象很容易，可以通过创建新的继承自Command的子类来实现这一点
Command模式可以和Memento模式结合起来，支持取消的操作

20.Visit
访问者模式，在当需求变量时，将更新（变更）封装到一个类中（访问操作），并由待更改类提供一个接收接口

21.

22.Iterator
对一个聚合对象的遍历问题，将对聚合的遍历封装到一个类中进行

23.Interpreter
Interpreter 模式提供了一种很好的组织和设计这种解析器的架构。使用类来表示文法规则，因此可以很容易实现文法的扩展

单例、工厂、策略、代理、观察者、适配器
原有类不能满足目标要求，通过创建适配器继承原有类实现目标接口